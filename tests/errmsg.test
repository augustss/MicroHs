amodule M() where
-----
mhs: "../tmp/E.hs": line 2, col 1:
  found:    amodule
  expected: module

=====
module M() where
x :: Int
x = 1 +
y = 0
-----
mhs: "../tmp/E.hs": line 5, col 1:
  found:    ;
  expected: SymOper LQIdent ( UQIdent [ literal primitive \ case let if QualDo do

=====
module E() where
import Prelude
x = y
-----
mhs: "../tmp/E.hs": line 4, col 1: undefined type signature: x

=====
module E() where
import Prelude
x :: Int
x = y
-----
mhs: "../tmp/E.hs": line 5, col 5: undefined value: y

=====
module E() where
import Prelude
x :: Int
x = A
-----
mhs: "../tmp/E.hs": line 5, col 5: undefined value: A

=====
module E() where
import Prelude
x :: T
x = 1
-----
mhs: "../tmp/E.hs": line 4, col 6: undefined type: T

=====
module E() where
import Prelude
x :: a
x = 1
-----
mhs: "../tmp/E.hs": line 4, col 6: undefined type: a

=====
module E() where
import Prelude
x :: Int
x = 1
y :: Int
y = 2
x :: Int
x = 3
-----
mhs: "../tmp/E.hs": line 5, col 1: duplicate definition E.x

=====
module E() where
import Prelude
type T a = [a]
data D (f :: Type -> Type) = D (f Int)
x :: D T
x = [0]
-----
mhs: "../tmp/E.hs": line 6, col 8: bad synonym use

=====
module E(module M) where
-----
mhs: "../tmp/E.hs": line 2, col 17: undefined module: M

=====
module E(T) where
-----
mhs: "../tmp/E.hs": line 2, col 10: undefined export: T

=====
module E(T(..)) where
-----
mhs: "../tmp/E.hs": line 2, col 10: undefined export: T

=====
module E(x) where
-----
mhs: "../tmp/E.hs": line 2, col 10: undefined export: x

=====
module E(lookupBy) where
import Prelude
import Data.Map
-----
mhs: "../tmp/E.hs": line 2, col 10: ambiguous export: lookupBy [Data.List.lookupBy,Data.Map.lookupBy]

=====
module E() where
import Prelude
import Data.Map
a :: ()
a = lookupBy
-----
mhs: "../tmp/E.hs": line 6, col 5: ambiguous value: lookupBy [Data.List.lookupBy,Data.Map.lookupBy]

=====
module E() where
import Prelude
infixl 5 +++
infixr 5 ***
(+++) :: Int -> Int -> Int
(+++) = (+)
(***) :: Int -> Int -> Int
(***) = (*)
x :: Int
x = 1 +++ 2 *** 3
-----
mhs: "../tmp/E.hs": line 11, col 13: ambiguous operator expression

=====
module E() where
import Prelude
a :: Int
a = 'a'
-----
mhs: "../tmp/E.hs": line 5, col 5: Cannot satisfy constraint: (Char ~ Int)

=====
module E() where
import Prelude
data T = C Maybe
-----
mhs: "../tmp/E.hs": line 4, col 12: kind error: cannot unify Type and (a2 -> a3)

=====
module E() where
import Prelude
data T = forall a . C a
x :: Int
x = let { C a = C (1::Int) } in a
-----
mhs: "../tmp/E.hs": line 6, col 11: existentials not allowed in pattern binding

=====
END
